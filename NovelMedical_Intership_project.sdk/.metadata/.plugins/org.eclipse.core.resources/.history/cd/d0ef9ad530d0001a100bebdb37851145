#include "tcp_server_func.h"

extern struct netif server_netif;
static struct tcp_pcb *connected_TCP_pcb = NULL; // connected_pcb c_pcb

extern TCP_User_Recv_Buf;
extern TCP_User_Send_Buf;
extern u8 tcp_udp_server_flag;	 //Server 测试全局状态标记变量

#define SEND_SIZE 2000
char TCPsendBuffer[SEND_SIZE];
#define RECV_SIZE 2000
char TCPrecvBuffer[RECV_SIZE];

int tcp_poll_cnt = 0;
int tcp_sent_cnt = 0;
int count_for = 0;
int Test_counter = 0;

char test_char[] = "test! \r\n";

extern int flag_test_commend;


//********************************

void TCP_print_app_header(void)
{
	xil_printf("TCP server listening on port %d\r\n",
			TCP_CONN_PORT);
#if LWIP_IPV6==1
	xil_printf("On Host: Run $iperf -V -c %s%%<interface> -i %d -t 300 -w 2M\r\n",
			inet6_ntoa(server_netif.ip6_addr[0]),
			INTERIM_REPORT_INTERVAL);
#else
	xil_printf("On Host: Run $iperf -c %s -i %d -t 300 -w 2M\r\n",
			inet_ntoa(server_netif.ip_addr),
			INTERIM_REPORT_INTERVAL);
#endif /* LWIP_IPV6 */
}


//*****************应用层 操作*******************************

void TCP_print_received_data(void){
	xil_printf("%s \r\n", TCPrecvBuffer);
}


//void main_send(const char *a, void * arg, struct tcp_pcb *tpcb){
//
//
//	//将数据先存入sendBuffer
//	memcpy(sendBuffer, a, sizeof(a));
//
//	//然后进行发送，以下是配套send_d的发送顺序
//	es->p = pbuf_alloc(PBUF_TRANSPORT,strlen((char*) sendBuffer),PBUF_POOL);
//	pbuf_take(es->p,(char*)sendBuffer,strlen((char*)sendBuffer));
//	send_data_d(tpcb,es);
//	//tcp_server_flag&=~(1<<7);  			//清除数据发送标志位
//	if(es->p != NULL) pbuf_free(es->p); //释放内存
//	}

void main_send_callback(char* a){
	xil_printf("callback_char is %s", a);
}

void main_send_use_callback(int i, void (*main_send_callback)(char*)){
	xil_printf("callback i is : %d \r\n", i);


}



//*******************RAW TCP 操作***************************

//四个发送函数，各自有各自不同的输入方式和调用方式，其实可以使用重载，但这里为直观和保险，进行重命名
// send_a 可以在其他函数中直接使用，无需任何参数
//内部使用了全局变量connected_pcb作为write中的输入参数，故无法指定其他的tcp_pcb
//缺点：？？？
void send_data_a()
{
	err_t err;

	itoa(Test_counter, TCPsendBuffer, 10);
	//strcat(Test_counter, " \0\r\n");

	struct tcp_pcb *tpcb = connected_TCP_pcb;

	if (!connected_TCP_pcb)
			return;

	err = tcp_write(tpcb, TCPsendBuffer, SEND_SIZE, 3);
	if (err != ERR_OK) {
		xil_printf("txperf: Error on tcp_write: %d\r\n", err);
		connected_TCP_pcb = NULL;
		return;
	}
	err = tcp_output(tpcb);
	if (err != ERR_OK) {
		xil_printf("txperf: Error on tcp_output: %d\r\n",err);
		return;
	}
	Test_counter++;
}


//send_b 使用pbuf* 为输入参数，发送该类型输入中已经存储的数据
//内部使用了全局变量connected_pcb作为write中的输入参数，故无法指定其他的tcp_pcb
void send_data_b(struct pbuf* p)
{
	err_t err;
	struct tcp_pcb *tpcb = connected_TCP_pcb;

	if (!connected_TCP_pcb)
			return;

	err = tcp_write(tpcb, p->payload, p->len, 3);
	if (err != ERR_OK) {
		xil_printf("txperf: Error on tcp_write: %d\r\n", err);
		connected_TCP_pcb = NULL;
		return;
	}
	err = tcp_output(tpcb);
	if (err != ERR_OK) {
		xil_printf("txperf: Error on tcp_output: %d\r\n",err);
		return;
	}
}



//send_c 使用tcp_pcb * 和 pbuf* 为输入参数，发送 pbuf*型输入中已经存储的数据
//可以根据不同的端口指定不同的任务的send（猜测）
void send_data_c(struct tcp_pcb *tpcb, struct pbuf* p){
	struct pbuf *ptr;
	u16 plen;
	err_t wr_err=ERR_OK;
	 while((wr_err==ERR_OK)&&p&&(p->len<=tcp_sndbuf(tpcb)))
	 {
		ptr=p;
		wr_err=tcp_write(tpcb,ptr->payload,ptr->len,1);
		if(wr_err==ERR_OK)
		{
			plen=ptr->len;
			p=ptr->next;			//指向下一个pbuf
			if(p) pbuf_ref(p);	//pbuf的ref加一
			pbuf_free(ptr);
			tcp_recved(tpcb,plen); 		//更新tcp窗口大小
		}else if(wr_err==ERR_MEM) p=ptr;//否则就不往后走
	 }
}


void send_data_c1(const char a[]){
	struct tcp_pcb *tpcb = connected_TCP_pcb;
	struct pbuf* temp_p;

	memcpy(TCPsendBuffer, a, sizeof(TCPrecvBuffer));
	temp_p = pbuf_alloc(PBUF_TRANSPORT,strlen((char*) TCPsendBuffer),PBUF_POOL);
	pbuf_take(temp_p,(char*)TCPsendBuffer,strlen((char*)TCPsendBuffer));
	send_data_c(tpcb, temp_p);
	if(temp_p != NULL) pbuf_free(temp_p);
}


//send_d 使用tcp_pcb * 和 tcp_server_struct * 为输入参数，发送tcp_server_struct * 的 pbuf*型输入中已经存储的数据
//与send_c 大同小异，只不过将pbuf* 集成进了tcp_server_struct *中，并加入了更多判断来加强安全性，当然也会更难使用
//可以根据不同的端口指定不同的任务的send（猜测）
void send_data_d(struct tcp_pcb *tpcb, struct tcp_server_struct *es){
	struct pbuf *ptr;
		u16 plen;
		err_t wr_err=ERR_OK;
		 while((wr_err==ERR_OK)&&es->p&&(es->p->len<=tcp_sndbuf(tpcb)))
		 {
			ptr=es->p;
			wr_err=tcp_write(tpcb,ptr->payload,ptr->len,1);
			if(wr_err==ERR_OK)
			{
				plen=ptr->len;
				es->p=ptr->next;			//指向下一个pbuf
				if(es->p) pbuf_ref(es->p);	//pbuf的ref加一
				pbuf_free(ptr);
				tcp_recved(tpcb,plen); 		//更新tcp窗口大小
			}else if(wr_err==ERR_MEM) es->p=ptr;
		 }
}


void TCP_send_data(const char a[]){
	tcp_udp_server_flag|=1<<7; // 标记发送数据
	struct tcp_pcb *tpcb = connected_TCP_pcb;
	u16 plen;
	err_t wr_err=ERR_OK;
	struct pbuf* temp_p;
	struct pbuf *ptr;
	memcpy(TCPsendBuffer, a, RECV_SIZE);
	temp_p = pbuf_alloc(PBUF_TRANSPORT,strlen((char*) TCPsendBuffer),PBUF_POOL);
	pbuf_take(temp_p,(char*)TCPsendBuffer,strlen((char*)TCPsendBuffer));

	 while((wr_err==ERR_OK)&&temp_p&&(temp_p->len<=tcp_sndbuf(tpcb)))
	 {
		ptr=temp_p;
		wr_err=tcp_write(tpcb,ptr->payload,ptr->len,1);
		if(wr_err==ERR_OK)
		{
			plen=ptr->len;
			temp_p=ptr->next;			//指向下一个pbuf
			if(temp_p) pbuf_ref(temp_p);	//pbuf的ref加一
			pbuf_free(ptr);
			tcp_recved(tpcb,plen); 		//更新tcp窗口大小
		}else if(wr_err==ERR_MEM) temp_p=ptr;//否则就不往后走
	 }
	if(temp_p != NULL) pbuf_free(temp_p);
}

void TCP_receive_commend(struct pbuf *p){
	xil_printf("\n**reading commend\r\n");
	tcp_udp_server_flag|=1<<0;

	u16_t pos1;
	pos1 = pbuf_memfind(p, "start", 5, 0);
	if (pos1 == 0xFFFF){
		xil_printf("start commend not found ! \r\n");
	}
	else{
		tcp_udp_server_flag|=1<<1;
		xil_printf("yes! start commend received \r\n");
	}
	u16_t pos2;
	pos2 = pbuf_memfind(p, "stop", 4, 0);
	if (pos2 == 0xFFFF){
		xil_printf("stop commend not found ! \r\n");
	}
	else{
		tcp_udp_server_flag &= ~(1<<1);
		xil_printf("yes! stop commend received \r\n");
	}
}


err_t tcp_recv_callback(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err)
{
	err_t ret_err;
	u32 data_len = 0;
	struct pbuf *q;
	struct tcp_server_struct *es;
	LWIP_ASSERT("arg != NULL",arg != NULL);
	es=(struct tcp_server_struct *)arg;

	/* 处于未建立状态则不要读取数据包 */
	if (p==NULL) {
		es->state=ES_TCPSERVER_CLOSING;//需要关闭TCP 连接了
		es->p=p;
		tcp_close(tpcb);
		xil_printf("tcp connection closed\r\n");
		tcp_recv(tpcb, NULL);
		return ERR_OK;
	}

	if(err!=ERR_OK){//从客户端接收到一个非空数据,但是由于某种原因err!=ERR_OK
		if(p)pbuf_free(p);	//释放接收pbuf
		ret_err=err;
	}else if(es->state==ES_TCPSERVER_ACCEPTED){//处于连接状态
		if(p!=NULL)  //当处于连接状态并且接收到的数据不为空时将其打印出来
		{
			//******************* 开始接收并存入buffer**********************
			TCP_receive_commend(p);
			memset(TCPrecvBuffer,0,RECV_SIZE);  //数据接收缓冲区清零
			for(q=p;q!=NULL;q=q->next)  //遍历完整个pbuf链表
			{
				//判断要拷贝到TCP_SERVER_RX_BUFSIZE中的数据是否大于TCP_SERVER_RX_BUFSIZE的剩余空间，如果大于
				//的话就只拷贝TCP_SERVER_RX_BUFSIZE中剩余长度的数据，否则的话就拷贝所有的数据
				if(q->len > (RECV_SIZE-data_len)) memcpy(TCPrecvBuffer+data_len,q->payload,(RECV_SIZE-data_len));//拷贝数据
				else memcpy(TCPrecvBuffer+data_len,q->payload,q->len);
				data_len += q->len;
				if(data_len > RECV_SIZE){
					break; //超出TCP客户端接收数组,跳出
				}
			}
			tcp_udp_server_flag|=1<<6;	//标记接收到数据了

			tcp_recved(tpcb, p->len);   //已收到数据包
			//***********************接收结束，已存入buffer************************

			//memcpy(&main_recv_Buf, &recvBuffer, sizeof(recvBuffer));

			strcpy(&TCP_User_Recv_Buf, &TCPrecvBuffer);

			//***//***//***//***可添加几个处理程序来处理收到的信息然后写入发送buf，完成处理**
//			memcpy(sendBuffer, recvBuffer, sizeof(recvBuffer)); //将收到的数据转发



			//***********************开始发送，从buffer中读取***********************

//			struct pbuf* temp_p;
//			temp_p = pbuf_alloc(PBUF_TRANSPORT,strlen((char*) sendBuffer),PBUF_POOL);
//			pbuf_take(temp_p,(char*)sendBuffer,strlen((char*)sendBuffer));
//			send_data_c(tpcb, temp_p);
//			if(temp_p != NULL) pbuf_free(temp_p);

			//备选方法
//			es->p = pbuf_alloc(PBUF_TRANSPORT,strlen((char*) sendBuffer),PBUF_POOL);
//			pbuf_take(es->p,(char*)sendBuffer,strlen((char*)sendBuffer));
//			send_data_d(tpcb,es);
//			//tcp_server_flag&=~(1<<7);  			//清除数据发送标志位
//			if(es->p != NULL) pbuf_free(es->p); //释放内存

			//***********************结束发送，从buffer中读取完毕***********************


			pbuf_free(p);    //释放pbuf
			ret_err=ERR_OK;
		}
	}else//服务器关闭了
	{
		tcp_recved(tpcb,p->tot_len);//用于获取接收数据,通知LWIP可以获取更多数据
		es->p=NULL;
		pbuf_free(p); //释放内存
		ret_err=ERR_OK;
	}
	return ret_err;
}

//关闭tcp连接
void tcp_server_connection_close(struct tcp_pcb *tpcb, struct tcp_server_struct *es)
{
	tcp_close(tpcb);
	tcp_arg(tpcb,NULL);
	tcp_sent(tpcb,NULL);
	tcp_recv(tpcb,NULL);
	tcp_err(tpcb,NULL);
	tcp_poll(tpcb,NULL,0);
	if(es)mem_free(es);
	tcp_udp_server_flag&=~(1<<5);//标记连接断开了
	xil_printf("TCP server closed \r\n");
}

err_t tcp_poll_callback(void * arg, struct tcp_pcb * tpcb)
{
	err_t ret_err;
	struct tcp_server_struct *es;
	es=(struct tcp_server_struct *)arg;

	tcp_poll_cnt++;     //统计发送数据的次数
	xil_printf("poll int:%d\r\n", tcp_poll_cnt);
	if(es!=NULL)
	{
		if(tcp_udp_server_flag&(1<<7))	//判断是否有数据要发送
		{
			//以下代码仅作实例用于日后理解与使用，若需发送需打开flag
			xil_printf("polling test \r\n");
			memcpy(TCPsendBuffer, test_char , sizeof(test_char));
			es->p = pbuf_alloc(PBUF_TRANSPORT,strlen((char*) TCPsendBuffer),PBUF_POOL);
			pbuf_take(es->p,(char*)TCPsendBuffer,strlen((char*)TCPsendBuffer));
			send_data_d(tpcb,es);
			//tcp_server_flag&=~(1<<7);  			//清除数据发送标志位
			if(es->p != NULL) pbuf_free(es->p); //释放内存
		}else if(es->state==ES_TCPSERVER_CLOSING)//需要关闭连接?执行关闭操作
		{
			tcp_server_connection_close(tpcb,es);//关闭连接
		}
		ret_err = ERR_OK;
	}else
	{
		tcp_abort(tpcb);//终止连接,删除pcb控制块
		ret_err=ERR_ABRT;
	}

	return ret_err;
}


static err_t tcp_sent_callback(void *arg, struct tcp_pcb *tpcb, u16_t len)
{
	struct tcp_server_struct *es;
	LWIP_UNUSED_ARG(len);
	es = (struct tcp_server_struct *) arg;
	if(es->p) send_data_d(tpcb,es);//发送数据，保险起见（可能会有没处理完的）

	tcp_sent_cnt++; //统计发送数据的次数
	//xil_printf("sent counte : %d \r\n", tcp_sent_cnt);
	return ERR_OK;
}


//lwIP tcp_err函数的回调函数
void tcp_server_error(void *arg,err_t err)
{
	LWIP_UNUSED_ARG(err);
	printf("tcp error \r\n");
	if(arg!=NULL)mem_free(arg);//释放内存
}

err_t tcp_server_accept(void *arg,struct tcp_pcb *tpcb,err_t err){
	xil_printf("tcp_server: Connection Accepted\r\n");
	err_t ret_err;
	struct tcp_server_struct *es;
	LWIP_UNUSED_ARG(arg);
	LWIP_UNUSED_ARG(err);
	tcp_setprio(tpcb,TCP_PRIO_MIN);//设置新创建的pcb优先级
	es=(struct tcp_server_struct*)mem_malloc(sizeof(struct tcp_server_struct)); //分配内存

	if(es!=NULL) //内存分配成功
	{
		es->state=ES_TCPSERVER_ACCEPTED;  	//接收连接
		es->pcb=tpcb;
		es->p=NULL;

		connected_TCP_pcb = tpcb;   //存储连接的TCP状态
		tcp_nagle_disable(connected_TCP_pcb); // 停用nagle， 即不等栈满才发车//connected_pcb
		tcp_arg(connected_TCP_pcb,es);
		tcp_recv(connected_TCP_pcb, tcp_recv_callback);
		tcp_err(connected_TCP_pcb,tcp_server_error); 	//初始化tcp_err()回调函数
#if USE_TCP_POLL
		tcp_poll(connected_TCP_pcb, tcp_poll_callback, 2);// 2 -->> 1 次/秒
#endif
		tcp_sent(connected_TCP_pcb, tcp_sent_callback);

		tcp_udp_server_flag|=1<<5;				//标记有客户端连上了
		ret_err=ERR_OK;
	}else{
		ret_err=ERR_MEM;
	}


	return ret_err;
}




int TCP_start_application()
{
	struct tcp_pcb *TCP_server_pcb;
	err_t err;

	/*  创建新的TCP PCB  */
	TCP_server_pcb = tcp_new_ip_type(IPADDR_TYPE_ANY);
	if (!TCP_server_pcb) {
		xil_printf("txperf: Error creating PCB. Out of Memory\r\n");
		return -1;
	}
	/*  绑定本地端口  */
	err = tcp_bind(TCP_server_pcb, IP_ADDR_ANY, TCP_CONN_PORT);
	if (err != ERR_OK) {
	    xil_printf("tcp_server: Unable to bind to port %d: err = %d\r\n", TCP_CONN_PORT, err);
	    tcp_close(TCP_server_pcb);
	    return -2;
	}
    /*  监听连接  */
	TCP_server_pcb = tcp_listen(TCP_server_pcb);
	if (!TCP_server_pcb) {
		xil_printf("tcp_server: Out of memory while tcp_listen\r\n");
		tcp_close(TCP_server_pcb);
		return -3;
	}

	tcp_arg(TCP_server_pcb, NULL);

	/*  设置accept回调函数  */
	tcp_accept(TCP_server_pcb, tcp_server_accept);

	return 0;
}


